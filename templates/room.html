<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Room</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/style_room.css">

  <style>
    .wrap {
      display: flex;
      height: 100vh;
      gap: 12px;
      padding: 12px;
      box-sizing: border-box;
    }


    .chat {
      width: 20%;
      flex: 0 0 320px;
      background: #2c2c2c; 
      color: #fff;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .chat-header { padding: 10px; border-bottom: 1px solid #555; font-weight: bold; }
    #chat {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      list-style: none;
      margin: 0;
    }
    .chat-input {
      display: flex;
      padding: 10px;
      border-top: 1px solid #555;
      gap: 5px;
    }
    .chat-input input {
      background: #2c2c2c;
      color: #fff;
      border: 1px solid #666;
    }
    .chat-input input::placeholder { color: #ccc; }

 
    .board {
      flex: 1;
      background: #2c2c2c; 
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      padding: 10px;
      color: #fff;
    }
    .tools {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
      flex-wrap: wrap;
      color: #fff;
    }
    .tools input { margin-left: 5px; }
    canvas {
      flex: 1;
      border: 1px solid #555;
      border-radius: 8px;
      background: #fff;
      touch-action: none;
    }


    @media (max-width: 767px) {
      .wrap { flex-direction: column; height: auto; }
      .chat { width: 100%; height: 250px; margin-bottom: 12px; }
      .board { width: 100%; height: calc(100vh - 250px - 36px); }
    }
    .tools {
      position: relative;
      z-index: 10;
    }

    canvas {
      position: relative;
      z-index: 1;
    }

  </style>
</head>
<body>

<div class="wrap">
  <div class="chat">
    <div class="chat-header">
      Room: {{ username }}
      <div id="usersBox" style="margin-top:8px; font-weight:normal;">
        Users:
        <div id="usersList" style="margin-top:6px;"></div>
      </div>
    </div>
    <ul id="chat" class="flex-grow-1 overflow-auto list-unstyled p-2 mb-0"></ul>
    <div class="chat-input mt-auto d-flex gap-2">
      <input id="msg" class="form-control" placeholder="Type a message..." />
      <button id="sendBtn" type="button" class="btn btn-light">Send</button>
    </div>
    <div style="display: flex; margin-left: 10px; margin-bottom: 10px; opacity: 0.3;">
      Use /gpt to talk with AI
    </div>
  </div>

  <div class="board">
    <div class="tools">
      <b>Whiteboard</b>
      <label class="mb-0">Size <input id="penSize" type="range" min="1" max="12" value="3"></label>
      <label class="mb-0">Color <input id="penColor" type="color" value="#000000"></label>
      <button id="clearBtn" type="button" class="btn btn-outline-light btn-sm">Clear(local)</button>
      <button id="clearGlobalBtn" type="button" class="btn btn-danger btn-sm">Clear(global)</button>
    </div>
    <canvas id="wb"></canvas>
  </div>
</div>

<script>
  const roomId = "{{ room_id }}";
  const username = "{{ username }}";
  const chat = document.getElementById("chat");

  function addLine(user, text) {
    const li = document.createElement("li");
    li.textContent = `${user}: ${text}`;
    chat.appendChild(li);
    chat.scrollTop = chat.scrollHeight;
  }

  let ws = null;
  let reconnectTimer = null;
  async function usersList() {
    try {
      const res = await fetch(`/room-users?room=${encodeURIComponent(roomId)}`);
      const users = await res.json();

      const box = document.getElementById("usersList");
      if (!box) return;

      box.innerHTML = "";
      users.forEach(u => {
        const item = document.createElement("div");
        item.textContent = u;
        box.appendChild(item);
      });
    } catch (e) {
      console.log("room get users error:", e);
    }
  }
  
  function connectWS() {
    if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;

    const protocol = location.protocol === "https:" ? "wss" : "ws";
    ws = new WebSocket(`${protocol}://${location.host}/ws?room=${roomId}&username=${encodeURIComponent(username)}`);

    ws.onmessage = (e) => {
      const msg = JSON.parse(e.data);
      if (msg.type === "chat") addLine(msg.user, msg.text);
      if (msg.type === "draw") drawLine(msg.x0, msg.y0, msg.x1, msg.y1, msg.color, msg.size);
      if (msg.type === "clear") clearLocal();
    };

    ws.onclose = () => {
      if (reconnectTimer) return;
      reconnectTimer = setTimeout(() => { reconnectTimer = null; connectWS(); }, 1000);
    };
  }

  async function loadHistory() {
    chat.innerHTML = "";
    const res = await fetch(`/messages/${roomId}`);
    const list = await res.json();
    list.forEach(m => addLine(m.user, m.text));
  }

  loadHistory().catch(console.log).finally(connectWS);
  usersList();
	  setInterval(usersList, 1000);

  function sendChat() {
    const input = document.getElementById("msg");
    const text = input.value.trim();
    if (!text || !ws || ws.readyState !== WebSocket.OPEN) return;
    ws.send(JSON.stringify({ type: "chat", text }));
    input.value = "";
  }

  document.getElementById("sendBtn").addEventListener("click", sendChat);
  document.getElementById("sendBtn").addEventListener("touchend", (e) => {
    e.preventDefault();
    sendChat();
  });

  document.getElementById("clearBtn").addEventListener("click", clearLocal);
  document.getElementById("clearBtn").addEventListener("touchend", (e) => {
    e.preventDefault();
    clearLocal();
  });
  document.getElementById("clearGlobalBtn").addEventListener("click", clearGlobal);
  document.getElementById("clearGlobalBtn").addEventListener("touchend", (e) => {
    e.preventDefault();
    clearGlobal();
  });


  document.getElementById("msg").addEventListener("keypress", function(e) {
    if (e.key === "Enter") { e.preventDefault(); sendChat(); }
  });

  const canvas = document.getElementById("wb");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const ratio = window.devicePixelRatio || 1;
    canvas.width = Math.round(rect.width * ratio);
    canvas.height = Math.round(rect.height * ratio);
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  window.addEventListener("resize", resizeCanvas);
  setTimeout(resizeCanvas, 0);

  function drawLine(x0, y0, x1, y1, color, size) {
    ctx.strokeStyle = color;
    ctx.lineWidth = size;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.stroke();
  }

  function clearLocal() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const ratio = window.devicePixelRatio || 1;
    ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
  }

  function clearGlobal() {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "clear" }));
    }
  }

  function getPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const t = evt.touches ? evt.touches[0] : evt;

    const scaleX = rect.width ? (canvas.width / rect.width) : 1;
    const scaleY = rect.height ? (canvas.height / rect.height) : 1;

    const x = (t.clientX - rect.left) * scaleX;
    const y = (t.clientY - rect.top) * scaleY;

    const ratio = window.devicePixelRatio || 1;
    return { x: x / ratio, y: y / ratio };
  }

  let drawing = false;
  let last = null;

  function startDraw(e) {
    drawing = true;
    last = getPos(e);
    e.preventDefault();
    e.stopPropagation();
  }
  function moveDraw(e) {
    if (!drawing) return;
    const cur = getPos(e);
    const color = document.getElementById("penColor").value;
    const size = Number(document.getElementById("penSize").value);
    drawLine(last.x, last.y, cur.x, cur.y, color, size);
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "draw", x0: last.x, y0: last.y, x1: cur.x, y1: cur.y, color, size }));
    }
    last = cur;
    e.preventDefault();
    e.stopPropagation();
  }
  function endDraw(e) {
    drawing = false;
    last = null;
    e.preventDefault();
    e.stopPropagation();
  }

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    startDraw(e);
  });

  canvas.addEventListener("pointermove", moveDraw);
  canvas.addEventListener("pointerup", endDraw);
  canvas.addEventListener("pointercancel", endDraw);

  window.addEventListener("beforeunload", () => { if (ws) ws.close(); });
</script>

</body>
</html>
